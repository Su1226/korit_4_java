# final 키워드 
- final 키워드가 붙은 변수나 상수는 재대입이 불가능하다.
- 즉 변함없는 데이터를 사용하고 싶을 때 사용되는데,
- 변함없는 데이터라는 것을 알아볼 수 있기 쉽게 모두 대문자로 쓰며, snake 표기법을 사용한다.

```java
public class main {
    public static void main(String[] args) {
        final int VIP_POINT = 80;
        final int GOLD_POINT = 60;
        final int SILVER_POINT = 40;
        final int BRONZE_POINT = 20;
    }
}
```

# 자료형 변환 

- 변수의 자료형을 다른 자료형으로 변환하는 것을 의미한다. 
- 이때 변환되는 자료형은 변수가 담고 있는 값에 따라 결정된다. 
- 형 변환은 Up-Casting(암시적/묵시적)과 Down-Casting(명시적)이 있다.
- 자료형 변환에는 두 가지 방법이 있다.
  1. '(바꿀데이터타입)변수명'으로 작성한다.
  2. 새로운 변수를 선언하여 캐스팅이 이루어진 데이터를 집어넣는 방법.

## Up-Casting(업캐스팅)
: 더 큰 용량의 자료형으로 변환시키는 것.

```java
public class main {
    public static void main(String[] args) {
        // 1. Up-Casting(업캐스팅, 묵시적 변환)
        // 방법 1 : '(바꿀데이터타입)변수명'으로 작성한다.
        char cast1 = 'A';
        char cast2 = 'a';

        System.out.println("원형 : " + cast1);
        System.out.println("변형 : " + (int)cast1);

        System.out.println("원형 : " + cast2);
        System.out.println("변형 : " + (int)cast2);

        // 방법 2 : 새로운 변수를 선언하여 캐스팅이 이루어진 데이터를 집어넣는 방법.
        char cast3 = 'b';
        int cast3Number = cast3;

        System.out.println("변환 된 변수 : " + cast3Number);
    }
}
```

## Down-Casting(다운캐스팅)
:  더 큰 용량의 자료형을 작은 용량의 자료형으로 변환 시키는 것. 

```java
public class main {
    public static void main(String[] args) {
        // 2. Down-Casting(다운캐스팅, 명시적 변환) 
        int cast4 = 99;         // 방법 1 사용
        int cast5 = 100;        // 방법 2 사용

        char cast5Char = (char)cast5;

        System.out.println("원형 : " + cast4);
        System.out.println("변형 : " + (char)cast4);

        System.out.println("변환 된 변수 : " + cast5Char);
    }
}
```

## 자료형 크기 

| 타입     | 크기 (bits) | 부호 여부 | 표현 범위                                     | 비고                     |
|----------|-------------|-----------|-----------------------------------------------|------------------------|
| byte     | 8           | 있음      | -128 ~ 127                                    | 가장 작은 정수형, 최소 단위       |
| short    | 16          | 있음      | -32,768 ~ 32,767                              |                        |
| int      | 32          | 있음      | -2,147,483,648 ~ 2,147,483,647                | 기본 정수형                 |
| long     | 64          | 있음      | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 큰 수를 다룰 때 사용           |
| float    | 32          | 있음      | ±1.4E-45 ~ ±3.4E+38 (약 7자리 정밀도)         | 단정도 부동소수점              |
| double   | 64          | 있음      | ±4.9E-324 ~ ±1.8E+308 (약 15자리 정밀도)      | 배정도 부동소수점 (기본 실수형)     |
| char     | 16          | 없음      | 0 ~ 65,535 (유니코드 문자)                    | 유니코드 문자 저장 용도          |
| boolean  | 1 (JVM 내부 처리) | 없음      | true 또는 false                               | 논리형, 크기는 명시적으로 정의되지 않음 |


## 유니코드
![img.png](img.png)

- 'A'와 'a' 정도는 기억해두면 좋다.

### 자료형 변환 시 주의사항
UpCasting의 경우, 메모리 용량이 커지기만 하면 되기 때문에,
기존의 데이터가 변형이 일어나지 않아 암시적/묵시적(imlicit)으로 변형이 가능하지만,

DownCasting의 경우, 데이터를 축소하는 과정에서 메모리 용량을 벗어나게 되는 경우가 있다.
용량 오버에 해당하는 현상을 미리 점검하기 위해 다운캐스팅 시에는 명시적(explicit)으로만 변형이 가능하다.

# 조건문(Condition)
## if문
### if문
: if 다음에 있는 () 내의 조건식이 true일 때 {} 내의 실행문이 실행된다. 즉, false면 실행되지 않는다.
: if 다음에 있는 () 내의 조건식이 true일 때 {} 내의 실행문이 실행된다. 즉, false면 실행되지 않는다.

```java
public class main {
    public static void main(String[] args) {
        /*
          if (조건식) {    // 조건식 : true / false로 결론이 날 수 있는 식 또는 문장
                실행문;
                실행문;
                ....
          } else if (조건식) {
                실행문;
                실행문;
                ...
          } else {
                실행문;
                ...
          }
         */
        // 변수 선언 및 초기화
        int num1 = 10;

        if(num1 > 0) {
            System.out.println("num1은 양수입니다.");
        } // true -> 실행 o

        if(num1 > 15) {
            System.out.println("num1은 15보다 작습니다.");
        } // false -> 실행 x
    }
}

```

### if-else문
: if 다음에 있는 조건식이 true일 때는 if문 내의 {}의 실행문이 실행되고,
false일 때는 else 내의 {}의 실행문이 실행된다.

```java
public class main {
    public static void main(String[] args) {
        /*
        if (조건식) {
            실행문;
            실행문;
            ...
        } else {
            실행문;
            ...
        }
         */
        int num1 = 0;

        if(num1 > 0) {
            System.out.println("num1은 양수입니다.");
        } else {
            System.out.println("num1은 음수이거나 0입니다.");
        }
    }
}

```

### if-else if-else문
: if - else문과 달리, else if에는 별도의 조건식이 요구된다. else if의 개수에는 제한이 없다.

```java
public class main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int point = 0;
        final int VIP_POINT = 80;
        final int GOLD_POINT = 60;
        final int SILVER_POINT = 40;
        final int BRONZE_POINT = 20;
        
        System.out.print("회원 포인트를 입력하세요 >>> ");
        point = scanner.nextInt();

        if(point >= VIP_POINT) {
            System.out.println("회원 등급 : VIP");
        } else if (point >= GOLD_POINT) {
            System.out.println("회원 등급 : GOLD");
        } else if (point >= SILVER_POINT) {
            System.out.println("회원 등급 : SILVER");
        } else if (point > BRONZE_POINT) {
            System.out.println("회원 등급 : BRONZE");
        } else if (point <= BRONZE_POINT) {
            System.out.println("회원 등급 : NOMAL");
        } else {
            System.out.println("회원이 없습니다.");
        }
    }
}

```


### 삼항 연산자
- 조건식을 평가하여 true / false에 따라 두 가지 표현식 중 하나를 선택적으로 실행한다. 
- 형식 : 조건식 ? 표현식1 : 표현식2
- 조건식 : true / false로 평가 가능한 식.
- 표현식1 : 조건식이 true일 때 실행되는 코드.
- 표현식2 : 조건식이 false일 때 실행되는 코드.

1. 논리 연산자로 만든 윤년 계산기 
```java
public class main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int year;
        String leapYear = "";

        System.out.print("연도를 입력하세요. >>> ");
        year = scanner.nextInt();

        if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
            if(year <= 0) {
                leapYear = "윤년이 아닙니다.";
            }

            leapYear = "윤년입니다.";
        } else {
            leapYear = "윤년이 아닙니다.";
        }

        System.out.println(year + "년도는 " + leapYear);
    }
}
```
2. 삼항 연산자로 만든 윤년 계산기 
```java
public class main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int year;
        String leapYear = "";

        System.out.print("연도를 입력하세요. >>> ");
        year = scanner.nextInt();
        
        // 삼항 연산자를 이용한 윤년 계산기
        boolean isLeapYear;
        isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);

        String result = year < 0 ? "불가능한 연도입니다."
                : isLeapYear ? "윤년입니다." : "평년입니다.";

        System.out.println(year + "년은 " + result);
    }
}
```
- 삼항 연산자를 사용 시, 코드를 좀 더 간결하게 작성할 수 있다는 장점을 가지고 있지만, 코드가 짧다고 해서 if문에 비해 속도가 빠르지는 않는다. 
- 또한, 축약된 형식이기 때문에 잘못 사용할 경우에는 소스 코드의 가독성을 해치기도 한다.  

## Switch문 

## while문


